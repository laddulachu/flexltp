{
  "name": "powwow-server-common",
  "version": "1.5.0",
  "private": true,
  "description": "Powwow Web Transformation server.",
  "main": "index.js",
  "scripts": {
    "prestart": "npm install",
    "start": "nodemon start.js | bunyan -o short --color"
  },
  "author": {
    "name": "Samir Mahendra"
  },
  "license": "MIT",
  "dependencies": {
    "bunyan": "1.5.1",
    "faker": "latest",
    "moment": "latest",
    "nodemon": "latest",
    "promise": "latest",
    "request": "latest",
    "underscore": "latest",
    "websocket": "latest",
    "async": "latest",
    "asynquence": "latest",
    "asynquence-contrib": "latest",
    "jsondiffpatch": "latest"
  },
  "gitHead": "def7592d397c4899533d8e7a41920fc191838cdb",
  "readme": "# Powwow Server Common\r\n\r\nv5 - Node phantom simple now built-in (since it needed too many patches).\r\n     Screenconfig has been removed.  Now directlty using screen ids.\r\nv4 - Single Selectors now check if node is visible before returning it.  This can be changed by adding { \"selectHidden\": true }\r\nv3 - Uses node-phantom-simple wrapper and PhantomJS 2.1.1.\r\n\r\nNote: Due to this bug in node-phantom-simple: https://github.com/baudehlo/node-phantom-simple/issues/132 - you will need to patch bridge.js before 'onClosing' handlers will work.\r\n\r\nThis module provides the following functionality:\r\n\r\n- Page Models\r\n- Page API\r\n- Websocket RPC API\r\n\r\n## The main application that includes this module should provide\r\n\r\n### config.json - Contains start URL for app and logging settings.\r\n\r\n## In api/index.js\r\n\r\nRequires for all the state files, which have\r\n\r\n- States registration based on URL patterns and # of frames loaded\r\n- API calls for state actions.\r\n\r\n## In inject/index.json\r\n\r\nA JSON array containing list of files to inject.  These get injected after \"common.js\".\r\n\r\n- Field page models and any app specific field types.\r\n\r\n\r\n## What is this?\r\n\r\n_Node Module for helping with Web Page transformation_\r\n\r\nHandles the following:\r\n\r\n1) Managing the websocket session\r\n\r\n2) Screen management (screen and subscreens, reconnect...)\r\n   - subscreens are for tracking different client side pages.\r\n\r\n3) Getting events and passing them to into the main application\r\n  - Page Loaded event\r\n     - All states are checked for matching URLs.\r\n     - Dealing with multi frame page loads, can count frames.\r\n\r\n  - Resource loaded event.\r\n     - These are good to know because when a click makes a XHR request,\r\n       waiting for the XHR response is better than a timer.  We can then look\r\n       for specific DOM mutations.\r\n\r\n  - DOM mutation events\r\n     - These will tell us when the DOM has changed in the background.\r\n\r\n4) Injecting common Javascript into the page context\r\n  - Code for clicking nodes, getting text, etc.\r\n  - General code for reading and setting data on the page based on the field page model.\r\n  - Field page models handle single fields as well as tables and lists.\r\n\r\nThis also contains a test page to kickstart testing of the API.\r\n\r\n## INFO\r\n\r\nUse test.html to connect to the server and test it out.\r\n\r\nCall \"export ENV=development\" to have the server start on port 3000.\r\n\r\nThe \"util\" built-in class has some useful methods:\r\n\r\n- util.getData - Takes a page model as the main parameter and returns the data that matches it\r\n\r\n- util.setData - Takes a page model and some data and calls the setters.  Format of input is {\"pageModel\": pageModel, \"values\": values}\r\n- util.callAction - Takes a page model and the item ID of the action to perform (i.e. clicks a button or link or submits a form.)  Format of input is {\"descriptor\": descriptor, \"action\": itemId}\r\n\r\nAll 3 calls above accept either a JSON page model object or a descriptor that is a string.  If it's a string, it's assumed that it's defined in the injected JS.\r\n\r\nsetData and callAction take a \"item id\" which is a path to the item in the JSON represented as a string.  E.g. for this data:\r\n\r\n{\r\n  \"myData\" {\r\n    \"mySubData\": \"something\",\r\n    \"myArray\" : [\r\n      { \"arrayItem\" : \"a thing\", \"arrayItem2\": 123 },\r\n      { \"arrayItem\" : \"another thing\", \"arrayItem2\": 456 }\r\n    ]\r\n  }\r\n}\r\n\r\nThe item ids are:\r\n\r\n- \"myData.mySubData\"\r\n- \"myData.myArray[0].arrayItem\"\r\n- \"myData.myArray[0].arrayItem2\"\r\n- \"myData.myArray[1].arrayItem\"\r\n- \"myData.myArray[1].arrayItem2\"\r\n\r\n- util.setSubScreen - Takes a { state: \"screen\", subscreen: \"subscreen\"} object and changes the subscreen.  Use this for navigation between subscreens so that the server knows the current subscreen.\r\n- util.snapshot - Take a screenshot of the page and returns the filename.\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "powwow-server-common@1.5.0",
  "_shasum": "e4ec81719177b6443bf0da27de19776182c5cd20",
  "_from": "..\\..\\..\\powwow-server-common",
  "_resolved": "file:..\\..\\..\\powwow-server-common"
}
